https://www.nowcoder.com/test/30545046/summary

https://www.nowcoder.com/test/question/done?tid=55367117&qid=1701665

网易互娱2021校园招聘在线笔试－游戏研发工程师（第一批） 企业提供原题
1/4
[编程题]迷宫寻宝-研发
时间限制：C/C++ 1秒，其他语言2秒

空间限制：C/C++ 64M，其他语言128M

一位冒险者进入了一个迷宫中寻宝。他手上已经拥有了一份这个迷宫的地图，其中标注了迷宫的完整结构以及迷宫中每个宝箱所在的位置。

迷宫的地图是一个由m*n个格子组成的平面图，纵向的上下方向上每列有m个格子，横向的左右方向上每行有n个格子，其中每个格子为不能进入的障碍格或可以进入的通行格。如果有两个上下相邻或左右相邻的通行格，则可以从其中一个通行格走到另一个通行格。每个宝箱放置在不同的通行格中。

他的目标是收集到这个迷宫里的所有宝箱，因此他给自己在这个迷宫中寻宝制定了如下策略：

1. 计算出离他当前位置曼哈顿距离最小的未收集宝箱，如果有多个就选定最小编号那个，记为k号宝箱；

2. 如果他当前位置无法到达k号宝箱，则收集失败，流程结束；否则，计算出他当前位置到k号宝箱的最短路径长度，并且按上下左右的次序依次计算出如果向这个方向走一格通行格之后，到k号宝箱的最短路径长度是否有缩短，如果有缩短则往这个方向走一格；

3. 如果他当前所在位置有未收集宝箱，就收集这个宝箱。如果所有宝箱已经被收集，则收集完成。否则回到第1步并重复执行。

其中迷宫中两个位置的曼哈顿距离，是指这两个位置在上下方向的行差，加上左右方向的列差。如果用公式表示，如果两个位置分别为(x, y)和(u, v)，则这两个位置的曼哈顿距离为|x-u|+|y-v|。
两个位置间的一条路径，是指从其中一个位置开始，通过若干个相邻通行格，走到另一个位置，其中经过的通行格顺序。两个位置的最短路径，是指这两个位置的所有路径中，通过的通行格数量最少的路径。两个位置的最短路径长度，是指沿这两个位置的最短路径走的格数。

问在这种策略下收集所有宝箱，他需要走多少格？

数据范围：，，
进阶：时间复杂度，空间复杂度

输入描述:
输入第一行为一个正整数T，表示有T组数据。

每组数据的第一行为两个正整数m和n，分别表示迷宫地图的行数和列数。

接下来有m行，每行有n个字符，表示迷宫地图中这行每一个中的图例表示。图例如下：

#: 障碍格；

*: 冒险者当前位置，为通行格；

0-9: 每个宝箱所在位置，为通行格；

.: 其它通行格

其中冒险者当前位置在一个迷宫地图中是有且仅有一个的。表示宝箱的数字，在一个迷宫地图中最多只会出现一次，且如果有一个k（k>0)号宝箱在迷宫地图中，则k-1号宝箱也必定会在迷宫地图中。

 

数据范围：

对于所有数据，满足1<=T<=5, 1<=m<=50, 1<=n<=50。


输出描述:
对于每一组数据，输出一个正整数。如果冒险者能收集完所有宝箱，则输出他共走了多少格，否则输出-1。


输入例子1:
3
5 5
0...1
.#.#.
..*..
.#.#.
2...3
5 5
0...1
.#.#.
..*.#
.#.#.
2.#.3
5 5
....1
.####
..*..
####.
0....

输出例子1:
16
-1
-1

例子说明1:


在第一组数据中，冒险者先向上走2格，再向左走2格，收集了0号宝箱；然后向右走4格，收集了1号宝箱；然后向下走4格，收集了3号宝箱；再然后向右走4格，收集了2号宝箱，收集所有宝箱完成，共走了2+2+4+4+4=16格。

在第二组数据中，无法从当前位置走到3号宝箱所在的位置收集3号宝箱，因此无法完成收集所有宝箱的任务。

在第三组数据中，在初始位置依次执行策略：

1. 计算出与0号宝箱的曼哈顿距离为4，与1号宝箱的曼哈顿距离为4，因此选定0号宝箱；

2. 计算出当前位置到0号宝箱的最短路径长度为8，按上下左右的次序依次计算：

(1) 上方为障碍格，忽略；

(2) 下方为障碍格，忽略；

(3) 左方为通行格，如果走到左方的通行格，则到0号宝箱的最短路径长度为9，比当前的最短路径长度8大，因此不选择；

(4) 右方为通行格，如果走到右方的通行格，则到0号宝箱的最短路径长度为7，比当前的最短路径长度8小，因此向这个方向走一格。

3. 当前未收集完所有宝箱，回到策略步骤1继续执行；

4. 计算出与0号宝箱的曼哈顿距离为5，与1号宝箱的曼哈顿距离为3，因此选定1号宝箱；

5. 计算出当前位置到1号宝箱的最短路径长度为9，按上下左右的次序依次计算：

(1) 上方为障碍格，忽略；

(2) 下方为障碍格，忽略；

(3) 左方为通行格，如果走到左方的通行格，则到1号宝箱的最短路径长度为8，比当前的最短路径长度9大，因此向这个方向走一格；

6. 当前未收集完所有宝箱，回到策略步骤1继续执行。

要注意到此时，冒险者当前在初始位置上，且所有宝箱都还没有被收集，继续按策略执行的过程中，冒险者会在这个位置向右走一格再向左走一格的循环中，永远无法收集到所有宝箱。


#include<bits/stdc++.h>
using namespace std;
 
struct node
{
    int x,y,t;
}A[10];
 
char mp[55][55];
bool book[55][55];
int dp[55][55][10];//记录宝箱到每个点的最短距离 
int m,n;
int tx[4] = {0,1,0,-1};
int ty[4] = {1,0,-1,0};
int cnt;
void bfs(int x, int y, int id)//计算宝箱到每个点的最短距离 
{
    memset(book,0,sizeof(book));
    int cnt = 0;
    queue<node> q;
    node a;
    a.x = x;
    a.y = y;
    a.t = 0;
    book[x][y] = true;
    q.push(a);
    while(!q.empty())
    {
        node w = q.front();
        q.pop();
        for(int i = 0; i < 4; i++)
        {
            int xx = w.x + tx[i];
            int yy = w.y + ty[i];
            int temp = w.t+1;
            if(xx >= 1 && xx <= m && yy >= 1 && yy <= n && !book[xx][yy] && mp[xx][yy] != '#')
            {
                book[xx][yy] = true;
                dp[xx][yy][id] = temp;
                q.push(node{xx,yy,temp});
            }
        }
    }
}
 
int Bfs(int x, int y, int t) 
{
    node a;
    a.x = x;
    a.y = y;
    a.t = t;
    memset(book,0,sizeof(book));
    book[x][y] = 1;
    queue<node> q;
    q.push(a);
    int p = 0;
    while(!q.empty())
    {
        node w = q.front();
        q.pop();
        if(mp[w.x][w.y] >= '0' && mp[w.x][w.y] <= '9' && A[mp[w.x][w.y] - '0'].t == 0)
        {
            memset(book,0,sizeof(book));
            book[w.x][w.y] = 1;
            A[mp[w.x][w.y] - '0'].t = 1;
            p++;
        }
        if(p == cnt)
        {
            return w.t;
        }
        int maxn = 100005;
        int id;
        for(int i = 0; i < cnt; i++)
        {
            if(abs(A[i].x - w.x) + abs(A[i].y - w.y) < maxn && A[i].t == 0)
            {
                maxn = abs(A[i].x - w.x) + abs(A[i].y - w.y);
                id = i;
            }
        }
        for(int i = 0; i < 4; i++)
        {
            int xx = w.x + tx[i];
            int yy = w.y + ty[i];
            int temp = w.t+1;
            if(xx >= 1 && xx <= m && yy >= 1 && yy <= n && !book[xx][yy] && mp[xx][yy] != '#' && dp[xx][yy][id] < dp[w.x][w.y][id])
            {
                book[xx][yy] = 1;
                q.push(node{xx,yy,temp});
            }
        }
    }
    return -1;
}
int main()
{
    int t,x,y;
    cin >> t;
    while(t--)
    {
        memset(dp,0,sizeof(dp));
        cnt = 0;
        cin >> m >> n;
        cnt = 0;
        for(int i = 1; i <= m; i++)
        {
            for(int j = 1; j <= n; j++)
            {
                cin >> mp[i][j];
                if(mp[i][j] == '*')
                {
                    x = i;
                    y = j;
                }
                else if(mp[i][j] >= '0' && mp[i][j] <= '9')
                {
                    A[mp[i][j] - '0'].x = i;
                    A[mp[i][j] - '0'].y = j;
                    cnt++;
                }
            }
        }
        for(int i = 0; i < cnt; i++)
        {
            bfs(A[i].x, A[i].y, i);
        }
        int ans = Bfs(x,y,0);
        cout << ans << "\n";
        for(int i = 0; i < cnt; i++)
        {
            A[i].t = 0;
            A[i].x = 0;
            A[i].y = 0;
        }
    }
} 
